"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.needsParens = needsParens;
exports.needsWhitespace = needsWhitespace;
exports.needsWhitespaceAfter = needsWhitespaceAfter;
exports.needsWhitespaceBefore = needsWhitespaceBefore;
<<<<<<< HEAD
var whitespace = require("./whitespace.js");
var parens = require("./parentheses.js");
=======
var whitespace = require("./whitespace");
var parens = require("./parentheses");
>>>>>>> origin/master
var _t = require("@babel/types");
const {
  FLIPPED_ALIAS_KEYS,
  isCallExpression,
  isExpressionStatement,
  isMemberExpression,
  isNewExpression
} = _t;
function expandAliases(obj) {
<<<<<<< HEAD
  const map = new Map();
  function add(type, func) {
    const fn = map.get(type);
    map.set(type, fn ? function (node, parent, stack) {
      var _fn;
      return (_fn = fn(node, parent, stack)) != null ? _fn : func(node, parent, stack);
    } : func);
=======
  const newObj = {};
  function add(type, func) {
    const fn = newObj[type];
    newObj[type] = fn ? function (node, parent, stack) {
      const result = fn(node, parent, stack);
      return result == null ? func(node, parent, stack) : result;
    } : func;
>>>>>>> origin/master
  }
  for (const type of Object.keys(obj)) {
    const aliases = FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (const alias of aliases) {
        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }
<<<<<<< HEAD
  return map;
}
const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
=======
  return newObj;
}

const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
function find(obj, node, parent, printStack) {
  const fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}
>>>>>>> origin/master
function isOrHasCallExpression(node) {
  if (isCallExpression(node)) {
    return true;
  }
  return isMemberExpression(node) && isOrHasCallExpression(node.object);
}
function needsWhitespace(node, parent, type) {
<<<<<<< HEAD
  var _expandedWhitespaceNo;
=======
>>>>>>> origin/master
  if (!node) return false;
  if (isExpressionStatement(node)) {
    node = node.expression;
  }
<<<<<<< HEAD
  const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
=======
  const flag = find(expandedWhitespaceNodes, node, parent);
>>>>>>> origin/master
  if (typeof flag === "number") {
    return (flag & type) !== 0;
  }
  return false;
}
function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, 1);
}
function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, 2);
}
function needsParens(node, parent, printStack) {
<<<<<<< HEAD
  var _expandedParens$get;
=======
>>>>>>> origin/master
  if (!parent) return false;
  if (isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }
<<<<<<< HEAD
  return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, printStack);
=======
  return find(expandedParens, node, parent, printStack);
>>>>>>> origin/master
}

//# sourceMappingURL=index.js.map
